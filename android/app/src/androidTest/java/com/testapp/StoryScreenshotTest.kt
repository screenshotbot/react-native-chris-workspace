package com.testapp

import android.Manifest
import android.graphics.Bitmap
import android.graphics.Canvas
import android.util.Log
import android.view.View
import androidx.test.core.app.ActivityScenario
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.rule.GrantPermissionRule
import org.junit.Assert.assertTrue
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import java.io.File
import java.io.FileOutputStream

/**
 * Screenshot test that automatically discovers and tests all Storybook stories.
 *
 * This test reads the story manifest generated by the JS side and creates a screenshot
 * for each story. No manual test methods needed - just add stories to Storybook and they
 * get tested automatically.
 *
 * Usage:
 * 1. Run StoryManifestBootstrapTest first to generate the manifest
 * 2. Run this test to screenshot all discovered stories
 */
@RunWith(AndroidJUnit4::class)
class StoryScreenshotTest {

    companion object {
        private const val TAG = "StoryScreenshotTest"
        private const val REACT_NATIVE_LOAD_TIMEOUT_MS = 5000L
        private const val SCREENSHOTS_DIR = "/sdcard/screenshots/com.testapp.test/stories"
    }

    @get:Rule
    val permissionRule: GrantPermissionRule = GrantPermissionRule.grant(
        Manifest.permission.WRITE_EXTERNAL_STORAGE,
        Manifest.permission.READ_EXTERNAL_STORAGE
    )

    /**
     * Screenshots all stories found in the manifest.
     * Each story gets its own screenshot named after its ID.
     */
    @Test
    fun screenshotAllStories() {
        val manifestFile = File("/sdcard/screenshots/com.testapp.test/${StorybookRegistry.STORIES_FILE_NAME}")

        assertTrue(
            "Stories manifest not found. Run StoryManifestBootstrapTest first to generate it.",
            manifestFile.exists()
        )

        val stories = StorybookRegistry.getStoriesFromFile(manifestFile.parentFile!!)
        Log.d(TAG, "Found ${stories.size} stories to screenshot")

        assertTrue("No stories found in manifest", stories.isNotEmpty())

        var successCount = 0
        var failureCount = 0
        val failures = mutableListOf<String>()

        for (story in stories) {
            try {
                screenshotStory(story)
                successCount++
            } catch (e: Exception) {
                failureCount++
                val errorMsg = "${story.title}/${story.name}: ${e.message}"
                failures.add(errorMsg)
                Log.e(TAG, "Failed to screenshot story: $errorMsg", e)
            }
        }

        Log.d(TAG, "Screenshot results: $successCount passed, $failureCount failed")

        if (failures.isNotEmpty()) {
            Log.e(TAG, "Failed stories:\n${failures.joinToString("\n")}")
        }

        assertTrue(
            "Some stories failed to screenshot: ${failures.joinToString(", ")}",
            failures.isEmpty()
        )
    }

    private fun screenshotStory(storyInfo: StoryInfo) {
        val storyName = storyInfo.toStoryName()
        Log.d(TAG, "Screenshotting: $storyName (id: ${storyInfo.id})")

        val intent = android.content.Intent(
            androidx.test.core.app.ApplicationProvider.getApplicationContext(),
            StoryRendererActivity::class.java
        ).apply {
            putExtra(StoryRendererActivity.EXTRA_STORY_NAME, storyName)
        }

        val scenario = ActivityScenario.launch<StoryRendererActivity>(intent)

        // Wait for React Native to load and render
        Thread.sleep(REACT_NATIVE_LOAD_TIMEOUT_MS)

        scenario.onActivity { activity ->
            val rootView = activity.window.decorView.rootView

            // Use story ID as screenshot name (replace -- with _ for filesystem compatibility)
            val screenshotName = storyInfo.id.replace("--", "_")

            // Capture full screenshot without tiling
            saveFullScreenshot(rootView, screenshotName)

            Log.d(TAG, "Screenshot captured: $screenshotName")
        }

        scenario.close()
    }

    /**
     * Saves a full screenshot of the view as a single PNG file (no tiling).
     */
    private fun saveFullScreenshot(view: View, name: String) {
        // Create bitmap from view
        val bitmap = Bitmap.createBitmap(
            view.width,
            view.height,
            Bitmap.Config.ARGB_8888
        )
        val canvas = Canvas(bitmap)
        view.draw(canvas)

        // Ensure output directory exists
        val screenshotsDir = File(SCREENSHOTS_DIR)
        screenshotsDir.mkdirs()

        // Save as PNG
        val file = File(screenshotsDir, "$name.png")
        FileOutputStream(file).use { out ->
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)
        }

        Log.d(TAG, "Full screenshot saved to: ${file.absolutePath}")

        // Clean up bitmap
        bitmap.recycle()
    }
}
